<html><head> <link rel = "stylesheet" type = "text/css"  href="cssstyle.css"/></head><body><head><script type="text/javascript" src = "jsscript.js"></script></head><pre><br><br><br><a href = "Convert.cpp.htm">Convert.cpp - Convert.cpp.htm</a><br><a href = "Convert.h.htm">Convert.h - Convert.h.htm</a><br><a href = "FileSystem.cpp.htm">FileSystem.cpp - FileSystem.cpp.htm</a><br><a href = "Test1.cpp.htm">Test1.cpp - Test1.cpp.htm</a><br><a href = "Tokenizer.h.htm">Tokenizer.h - Tokenizer.h.htm</a><br><br><br>/////////////////////////////////////////////////////////////////////
// TemplatesIntro.cpp - Demonstrate Template Syntax                //
//                                                                 //
// Jim Fawcett, CSE687 - Object Oriented Design, Spring 2017       //
/////////////////////////////////////////////////////////////////////

#include "Convert.h"
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

/////////////////////////////////////////////////////////////////////
// Widget class - shows user defined types can be template arguments

class Widget
{<button onclick = "myFunc1()">+</button><div id = "mydiv1">
public:
  Widget(const std::string& str = "") : state(str) {<button onclick = "myFunc2()">+</button><div id = "mydiv2">}</div>
  std::string& value() {<button onclick = "myFunc3()">+</button><div id = "mydiv3"> return state; }</div>
private:
  std::string state;
}</div>;

std::ostream& operator&lt;&lt;(std::ostream& out, Widget& widget)
{<button onclick = "myFunc4()">+</button><div id = "mydiv4">
  out &lt;&lt; widget.value();
  return out;
}</div>

std::istream& operator &gt;&gt; (std::istream& in, Widget& widget)
{<button onclick = "myFunc5()">+</button><div id = "mydiv5">
  std::string temp;
  while (in.good())  // extract all the words from widget's string state
  {<button onclick = "myFunc6()">+</button><div id = "mydiv6">
    in &gt;&gt; temp;
    widget.value() += temp + " ";
  }</div>
  return in;
}</div>

/////////////////////////////////////////////////////////////////////
// lambdas that provide mildly useful local processing

std::function&lt;void()&gt; putLine = []() {<button onclick = "myFunc7()">+</button><div id = "mydiv7"> std::wcout &lt;&lt; "\n"; }</div>;

std::function&lt;void(size_t)&gt; putLines = [](size_t n) {<button onclick = "myFunc8()">+</button><div id = "mydiv8">
  for (size_t i = 0; i &lt; n; ++i)
    putLine();
}</div>;

std::function&lt;void(const std::string&, char)&gt; titleCore = [](const std::string& msg, char underline='-') {<button onclick = "myFunc9()">+</button><div id = "mydiv9">
  std::cout &lt;&lt; "\n  " &lt;&lt; msg.c_str();
  std::wcout &lt;&lt; "\n " &lt;&lt; std::string(msg.size() + 2, underline).c_str();
}</div>;

std::function&lt;void(const std::string&)&gt; Title = [](const std::string& msg) {<button onclick = "myFunc10()">+</button><div id = "mydiv10"> titleCore(msg, '='); }</div>;

std::function&lt;void(const std::string&)&gt; title = [](const std::string& msg) {<button onclick = "myFunc11()">+</button><div id = "mydiv11"> titleCore(msg, '-'); }</div>;

/////////////////////////////////////////////////////////////////////
// Demo code

int main()
{<button onclick = "myFunc12()">+</button><div id = "mydiv12">
  Title("Demonstrating Templates");
  putLine();

  title("Demonstrating Conversion of numerical types");
  std::cout &lt;&lt; "\n  conversion of integer: " &lt;&lt; Convert&lt;int&gt;::toString(42);
  std::cout &lt;&lt; "\n  conversion of double:  " &lt;&lt; Convert&lt;double&gt;::toString(3.1415927);
  putLine();

  title("Demonstrating Conversion of Widget type");
  Widget widget("Joe Widget");
  std::string widgetStore = Convert&lt;Widget&gt;::toString(widget);
  std::cout &lt;&lt; "\n  conversion of Widget: " &lt;&lt; widgetStore;

  Widget newWidget = Convert&lt;Widget&gt;::fromString(widgetStore);
  std::cout &lt;&lt; "\n  newWidget state = " &lt;&lt; newWidget.value();

  putLines(2);
}</div>
</pre></body></html>